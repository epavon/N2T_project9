class ChessPieceHelper {

	function ChessPiece getByPosition(Array clearPieces, Array stripePieces, Point position) {
		var int i;
        var ChessPiece curPiece;
        var Point curPiecePosition;

        let i = 0;

        while(i < 16) {        
        	let curPiece = clearPieces[i];                
            let curPiecePosition = curPiece.getPosition();
			if(curPiece.getIsAlive()) {
            	if(curPiecePosition.getX() = position.getX() ) {
            	    if( curPiecePosition.getY() = position.getY()) {
            	        return curPiece;
            	    }
            	}
			}

			let curPiece = stripePieces[i];
			let curPiecePosition = curPiece.getPosition();
			if(curPiece.getIsAlive()) {
            	if(curPiecePosition.getX() = position.getX() ) {
            	    if( curPiecePosition.getY() = position.getY()) {
            	        return curPiece;
            	    }
            	}
			}

            let i = i + 1;
        }

        return null;	
	}

	function void drawPieceInPos(Point position, Array clearPieces, Array stripePieces) {
		var ChessPiece piece;		
		let piece = ChessPieceHelper.getByPosition(clearPieces, stripePieces, position);

		if(~(piece = null)) {
			do piece.draw(ChessPieceHelper.onLight(position));
		}

		return;
	}

	function boolean onLight(Point position) {
		var int x, y;
		let x = position.getX() - 122;
		let y = position.getY();		
		 
		if(MathHelper.modulo(y /32, 2) = 0) {
			if(MathHelper.modulo(x/32, 2) = 1) {
				return true;
			}
		}

		if(MathHelper.modulo(y/32, 2) = 1) {
			if(MathHelper.modulo(x/32, 2) = 0) {
				return true;
			}
		}

		return false;
	}

	function boolean comparePosition(Point pos1, Point pos2) {
		if(pos1.getX() = pos2.getX()) {
			if(pos1.getY() = pos2.getY()) {
				return true;
			}
		}
		return false;
	}

	function boolean isPieceInPos(Point position, Array clearPieces, Array stripePieces) {
		var ChessPiece pieceInDesiredPos;
		let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, position);

		if(pieceInDesiredPos = null) {
			return true;
		}
		return false;
	}

	// @TODO: Do for all pieces, take into account other pieces..
	function boolean canMove(ChessPiece piece, Point desiredPos, Array clearPieces, Array stripePieces) {
		var Point piecePos;
		let piecePos = piece.getPosition();
		
		if(piece.getType() = ChessPieceHelper.getPawnType()) {
			return ChessPieceHelper.canPawnMove(piece, desiredPos, clearPieces, stripePieces, piece.getInInitialPos());
		}
		if(piece.getType() = ChessPieceHelper.getRookType()) {
			return ChessPieceHelper.canRookMove(piece, desiredPos, clearPieces, stripePieces);
		}
		if(piece.getType() = ChessPieceHelper.getKnightType()) {
			return ChessPieceHelper.canKnightMove(piece, desiredPos, clearPieces, stripePieces);
		}
		if(piece.getType() = ChessPieceHelper.getBishopType()) {
			return ChessPieceHelper.canBishopMove(piece, desiredPos, clearPieces, stripePieces);
		}
		if(piece.getType() = ChessPieceHelper.getQueenType()) {
			return ChessPieceHelper.canQueenMove(piece, desiredPos, clearPieces, stripePieces);
		}
		if(piece.getType() = ChessPieceHelper.getKingType()) {
			return ChessPieceHelper.canKingMove(piece, desiredPos, clearPieces, stripePieces);
		}

		return true;
	}

	function boolean canPawnMove(ChessPiece pawnPiece, Point desiredPos, Array clearPieces, Array stripePieces, boolean inInitialPos) {
		var ChessPiece pieceInDesiredPos;
		var Point piecePos, otherPos;
		var int posDiffCoeff;
		
		let piecePos = pawnPiece.getPosition();		
		if(pawnPiece.getIsClear()) {
			let posDiffCoeff = 1;
		} else {
			let posDiffCoeff = -1;
		}

		if(desiredPos.getX() = piecePos.getX()) {	//  VERTICAL MOVEMENT
			if(desiredPos.getY() - piecePos.getY() = (32 * posDiffCoeff) ) {
				let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, desiredPos);
				if(pieceInDesiredPos = null) {
					return true;
				}
			}
			else {
				if(desiredPos.getY() - piecePos.getY() = (64* posDiffCoeff)) {
					if(inInitialPos) {
						let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, desiredPos);
						if(pieceInDesiredPos = null) {
							let otherPos = Point.new(desiredPos.getX(), desiredPos.getY()-(32 * posDiffCoeff));
							let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, otherPos);
							if(pieceInDesiredPos = null) {
								return true;
							}
						}
					}
				}
			}
		}
		else {										// DIAGONAL MOVEMENT
			if(MathHelper.abs(desiredPos.getX() - piecePos.getX()) = 32) {
				if(desiredPos.getY() - piecePos.getY() = (32 * posDiffCoeff)) {
					let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, desiredPos);
					if(~(pieceInDesiredPos = null)) {
						do pieceInDesiredPos.setIsAlive(false);
						return true;
					} 
					else { // handle tricky case of opponent pawn moving past two spaces

					}
				}
			}
		}
		
		return false;
		
	}

	function boolean canRookMove(ChessPiece piece, Point desiredPos, Array clearPieces, Array stripePieces) {
		var ChessPiece pieceInDesiredPos;	
		var Point piecePos;
		var int i;

		let piecePos = piece.getPosition();				

		if(desiredPos.getX() = piecePos.getX()) {
			if(desiredPos.getY() > piecePos.getY()) {
				let i = piecePos.getY() + 32;
				while(i < desiredPos.getY()) {
					let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, Point.new(desiredPos.getX(), i));
					if(~(pieceInDesiredPos = null)) {
						return false;
					}
					let i = i + 32;
				}				
			}
			else {
				let i = piecePos.getY() - 32;
				while(i > desiredPos.getY()) {
					let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, Point.new(desiredPos.getX(), i));
					if(~(pieceInDesiredPos = null)) {
						return false;
					}
					let i = i - 32;
				}				
			}

			let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, desiredPos);
			if(pieceInDesiredPos = null) {
				return true;
			}
			else {
				if(~(piece.getIsClear() = pieceInDesiredPos.getIsClear())) {
					return true;
				}
			}
		}
		else {
			if(desiredPos.getY() = piecePos.getY()) {
				if(desiredPos.getX() > piecePos.getX()) {
					let i = piecePos.getX() + 32;
					while(i < desiredPos.getX()) {
						let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, Point.new(i,desiredPos.getY()));
						if(~(pieceInDesiredPos = null)) {
							return false;
						}
						let i = i + 32;
					}				
				}
				else {
					let i = piecePos.getX() - 32;
					while(i > desiredPos.getX()) {
						let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, Point.new(i,desiredPos.getY()));
						if(~(pieceInDesiredPos = null)) {
							return false;
						}
						let i = i - 32;
					}				
				}

				let pieceInDesiredPos = ChessPieceHelper.getByPosition(clearPieces, stripePieces, desiredPos);
				if(pieceInDesiredPos = null) {
					return true;
				}
				else {
					if(~(piece.getIsClear() = pieceInDesiredPos.getIsClear())) {
						return true;
					}
				}
			}
		}		 

		return false;		
	}

	function boolean canKnightMove(ChessPiece piece, Point desiredPos, Array clearPieces, Array stripePieces) {
		var Point piecePos;
		var ChessPiece pieceInDesiredPos;

		let pieceInDesiredPos 	= ChessPieceHelper.getByPosition(clearPieces, stripePieces, desiredPos);
		let piecePos 			= piece.getPosition();

		if(MathHelper.abs(piecePos.getX() - desiredPos.getX()) = 32) {
			if(MathHelper.abs(piecePos.getY() - desiredPos.getY()) = 64) {
				if(~(pieceInDesiredPos = null)) {
					if(~(pieceInDesiredPos.getIsClear() = piece.getIsClear())) {
						do pieceInDesiredPos.setIsAlive(false);
						return true;
					}
				}
				else {
					return true;
				}				
			}
		}
		else {
			if(MathHelper.abs(piecePos.getX() - desiredPos.getX()) = 64) {
				if(MathHelper.abs(piecePos.getY() - desiredPos.getY()) = 32) {
					if(~(pieceInDesiredPos = null)) {
						if(~(pieceInDesiredPos.getIsClear() = piece.getIsClear())) {
							do pieceInDesiredPos.setIsAlive(false);
							return true;
						}
					}
					else {
						return true;
					}							
				}
			}
		}

		return false;
		
	}

	function boolean canBishopMove(ChessPiece piece, Point desiredPos, Array clearPieces, Array stripePieces) {
		
		if(piece.getIsClear()) {
			if(desiredPos.getX() = piecePos.getX()) {
				if(MathHelper.abs(desiredPos.getY() - piecePos.getY()) = 32) {
					return true;
				}
			}
			else {
			}
		} 
		else {

		}

		return false;
		
	}

	function boolean canQueenMove(ChessPiece piece, Point desiredPos, Array clearPieces, Array stripePieces) {
		
		if(piece.getIsClear()) {
			if(desiredPos.getX() = piecePos.getX()) {
				if(MathHelper.abs(desiredPos.getY() - piecePos.getY()) = 32) {
					return true;
				}
			}
			else {
			}
		} 
		else {

		}

		return false;
		
	}

	function boolean canKingMove(ChessPiece piece, Point desiredPos, Array clearPieces, Array stripePieces) {
		
		if(piece.getIsClear()) {
			if(desiredPos.getX() = piecePos.getX()) {
				if(MathHelper.abs(desiredPos.getY() - piecePos.getY()) = 32) {
					return true;
				}
			}
			else {
			}
		} 
		else {

		}

		return false;
		
	}

	function int getPawnType() {
		return 5;
	}
    
	function int getKingType() {
		return 0;
	}

	function int getQueenType() {
		return 1;
	}

	function int getBishopType() {
		return 2;
	}

	function int getRookType() {
		return 4;
	}

	function int getKnightType() {
		return 3;
	}

}